DropBox是一个文件云存储服务，类似产品还有Google Drive、Onedrive等等。用户可以将文件存储于远端的服务器上，服务器由云服务提供商维护，用户按月付费。

# 云存储的优点

云端文件存储由于其简化了数字文件的存储和在不同设备之间的数据交换，变得越来越流行。

- 可用性：云存储服务可以在任何时间给用户提供来自任何地点访问的服务。
- 可靠性和持久性：云存储服务通常会将用户上传的数据存储位于不同地理位置的多台服务器上，以保证不会丢失数据。
- 伸缩性：用户不需要担心存储空间的问题，只要愿意付费，就能升级自己的存储空间。

# 系统需求分析

系统功能分析：

- 用户能够在任何终端设备上上传或下载文件、照片。
- 用户能够将自己的文件或文件夹分享给其他用户。
- 支持在不同设备之间自动同步。比如在一个设备上传一个文件，其他设备上能够自动同步该文件。
- 支持大文件存储（G级别）
- 对文件的操作支持ACID特性。
- 支持对文件进行离线编辑。在离线的时候用户对文件进行的编辑操作会暂存在本地，等设备重新上线时自动同步到云服务器以及其他终端设备。

可能需要支持的扩展功能：

- 支持数据多版本。用户能够选择回退到之前的版本。

# 一些设计上的考量

- 支持大数据量的读/写
- 读/写流量比例近乎相同
- 在内部文件以小的分块的形式存储比如4MB。这样当用户上传文件失败，重试的时候只需要重新上传文件的失败部分。
- 在不同设备间同步数据的时候，通过只同步更新的文件块可以减少数据的同步量级
- 通过移除数据相同的文件块，可以节省存储空间和带宽
- 如果文件只有一小部分变更了，客户端可以智能识别出变化的部分，这样可以避免上传整个文件至云服务器

# 容量预估

前提假设：

用户量：5亿，日活用户1亿（DAU）。

平均每个用户会从3台设备上使用客户端。

平均每个用户文件数200个，总文件数则是1000亿。

平均文件大小：100KB。那么总的文件大小是：

1000亿*100KB>=10PB。

活跃连接数：平均100万/分钟。

# 概要设计

用户可以在终端设备上指定一个本地文件夹作为工作目录，这个目录下的所有文件都会被上传至云端。当这个文件夹下有文件发生变更，变更内容也会被上传到云端。用户能够在多个终端设备上指定工作目录空间，一个设备上的文件变更会被同步到其他设备上。

我们需要存储文件及其元数据（文件名、文件大小、目录、以及和谁分享）信息。因此，需要有一些服务器负责上传文件到云端存储，另一些服务器上传元数据信息。当有文件发生变更的时候还要能够通知到所有客户端。

如下图，Block server负责上传/下载文件到云端文件存储服务器，metadata server负责维护文件的元数据信息，可能是SQL或NoSQL产品。Synchronization Server负责将文件变更通知到所有客户端。

![](https://cdn.nlark.com/yuque/0/2022/png/640636/1647763916186-a7cdf32a-acd0-49a4-aec5-bcee74649d32.png)

# 模块设计

## 客户端

客户端需要和block server一起负责文件的上传和下载，还需要和Synchronization server交互处理元数据更新。

客户端支持的必备操作总结如下：

- 上传和下载文件
- 检测终端工作目录下的文件变更
- 处理离线更新或并发更新导致的文件冲突

### 客户端设计的几点考量

1、如何高效处理文件传输

主要是前面提到的文件分块。文件块大小设置为多大比较合适呢？和多个因素相关：

- 云端使用的存储设备、读写频率
- 网络带宽
- 平均文件大小

2、是否需要在客户端维护一份元数据

在客户端保存一份本地元数据备份，一可以进行离线编辑，二是可以减少和远端元数据服务器的交互。

3、客户端如何有效监听其他客户端的文件变更

其中一种可选的方法是由客户端定期轮询服务端是否有文件变更发生。这个方法的问题在于客户端在展示最新的文件变更上存在延时。如果客户端轮询的频率过高，那么会浪费带宽、以及会占用服务端的连接资源。因此这种拉的方式伸缩性不好。

解决上述问题的一个办法是采用http长轮询机制，客户端在发送请求给服务端以后，服务端并不会立即响应结果。在服务端发现没有文件变更的时候，不会立即返回空响应结果给客户端，而是等待有了文件变更的时候立即发送响应给客户端。客户端收到响应结果后再次发送另一个请求给服务端，等待下一次响应。

也可以使用websocket。

### 客户端设计

基于以上几个考虑，我们可以将客户端分为四部分：

- 存储元数据的DB。
- Chunker：负责将文件拆分为小的块、以及基于小的块重建得到原始文件。
- Watcher：负责监听本地工作目录下的文件变更通知Indexer，以及监听由Synchronization服务器关于其他客户端发生的文件变更的广播通知。
- Indexer：处理来自Watcher的通知事件，更新发生变更的文件的块信息至客户端本地元数据存储DB。当文件块被成功长传到云存储，Indexer会和通知Synchronization服务器进行广播通知告知其他客户端、以及更新远端元数据存储DB。

![](https://cdn.nlark.com/yuque/0/2022/png/640636/1647768222674-24ab68da-647f-47b0-bf79-5ff2c9a505c9.png)

需要注意的2个点：

- 如果服务端响应比较慢，客户端需要延迟其重试操作避免造成服务端延迟恶化。
- 移动设备可以适当降低同步频率以节省带宽。

## 元数据数据库设计

元数据数据库负责维护文件块、用户、工作空间的版本信息和元数据信息。Synchronization服务需要保证文件的一致性，尤其是当多个用户同时操作同一个文件的时候。由于NoSQL为了伸缩性和性能考虑不支持ACID，我们需要在程序上自己保证ACID，增加了复杂性。因此我们可以采用关系型数据库简化我们的系统设计。

元数据DB需要存储以下内容的信息：

- 文件块
- 文件
- 用户
- 终端设备
- 工作空间

## Synchronization service(同步服务)
